# Subject Ontology Design: SubjectConcept → Authority Federation

**Date**: 2026-02-15  
**Purpose**: Comprehensive subject domain modeling through LCC, LCSH, FAST, MARC  
**Status**: Architectural discussion for Phase 2+ implementation

---

## 1. Full Ontology Graph Model

```
SubjectConcept (Central Hub)
    ├── [:ALIGNED_WITH_LCC] → LCC_Class
    ├── [:ALIGNED_WITH_LCSH] → LCSH_Subject
    ├── [:ALIGNED_WITH_FAST] → FAST_Subject
    ├── [:ALIGNED_WITH_MARC] → MARC_Record
    ├── [:HAS_FACET_CLAIM] → Claim (facet: "Military", confidence: 0.95)
    ├── [:HAS_CHILD_CONCEPT] → SubjectConcept (more granular)
    └── [:HAS_REGISTRY_ENTRY] → SubjectConceptRegistry
```

### **SubjectConcept Node Structure**

```cypher
(:SubjectConcept {
  // Identity
  concept_id: "subj_roman_republic_q17167",
  label: "Roman Republic",
  wikidata_qid: "Q17167",
  
  // Authority Links (Pointers, not duplicated data)
  lcc_codes: ["DG232-DG248"],                    // Array of aligned LCC classes
  lcsh_ids: ["sh85114436"],                      // Array of LCSH IDs
  fast_ids: [1352255, 1352256],                  // Array of FAST ID numbers
  
  // Parentage
  parent_concept_id: null,                       // For hierarchy (e.g., child: "Caesar's Gallic Wars" → parent: "Roman Military Campaigns")
  is_canonical: true,                           // vs. variant/alias concept
  
  // Temporal Scope
  period_start: -509,                           // Year BCE/CE
  period_end: -27,
  temporal_bounds_confidence: 0.98,
  
  // Source & Confidence
  source: "Wikidata + LCC DG + LCSH",
  is_agent_created: false,                      // vs. generated by user/agent
  agent_name: null,                             // If agent-created, which agent?
  creation_timestamp: datetime("2026-02-15"),
  
  // Facet Claims (Links to Claim nodes)
  facet_claims_count: 8,                        // How many facet claims exist?
  facet_primaries: ["Military", "Political", "Diplomatic", "Social"],
  
  // Hierarchy Metadata
  concept_depth: 0,                             // 0 = root (Roman Republic)
                                                // 1 = children (Punic Wars, Caesar)
                                                // 2 = grandchildren (Battle of Cannae)
  child_concept_count: 45,                      // How many sub-concepts exist?
  registry_entry_id: "reg_roman_rep_001"        // Link to registry
})
```

### **Authority Alignment Relationships (Sparse Links)**

```cypher
// Link to LCC (No full LCC copy - just pointer + context)
(subj:SubjectConcept)-[:ALIGNED_WITH_LCC {
  lcc_range: "DG232-DG248",
  match_confidence: 0.95,
  validated_by: "human",
  coverage: "exact"  // exact, partial, approximate
}]->(lcc:LCC_Class {
  code: "DG232",
  label: "Republic (510-27 BC)",
  source: "Library of Congress Classification"
})

// Link to LCSH (Sparse - metadata only)
(subj)-[:ALIGNED_WITH_LCSH {
  lcsh_id: "sh85114436",
  match_confidence: 0.98,
  validated_by: "auto",
  coverage: "exact"
}]->(lcsh:LCSH_Subject {
  lcsh_id: "sh85114436",
  heading: "Rome--History--Republic, 510-30 B.C.",
  source: "Library of Congress Subject Headings",
  authority_tier: "TIER_1"
})

// Link to FAST (Authority number + minimal metadata)
(subj)-[:ALIGNED_WITH_FAST {
  fast_id: 1352255,
  match_confidence: 0.95,
  match_type: "exact"
}]->(fast:FAST_Subject {
  fast_id: 1352255,
  label: "Rome--History--Republic",
  source: "FAST Topical",
  authority_tier: "TIER_2"
})

// Link to MARC (Record reference)
(subj)-[:HAS_MARC_RECORD]->(marc:MARC_Record {
  marc_id: "marc_2026_0001",
  leader: "00000cam a2200000 i 4500",
  record_type: "Language material",
  bib_level: "Monograph"
})
```

### **Facet Claims (How SubjectConcept Intersects 17 Facets)**

```cypher
(subj:SubjectConcept {label: "Roman Republic"})-[:HAS_FACET_CLAIM]->(claim:Claim {
  claim_id: "claim_roman_rep_military_001",
  text: "The Roman Republic achieved military hegemony through legionary tactics",
  primary_facet: "Military",
  related_facets: ["Political", "Technological"],
  confidence: 0.95,
  evidence: "Livy's Ab Urbe Condita; Caesar's Commentarii",
  authority: {type: "LCSH", id: "sh85114436"},
  temporal_start: -509,
  temporal_end: -27,
  source_agent: "GPT_PHASE_2A+2B"
})

(subj)-[:HAS_FACET_CLAIM]->(claim2:Claim {
  text: "Roman Republican propaganda emphasized ancestral virtue (virtus patrum)",
  primary_facet: "Communication",
  related_facets: ["Political", "Cultural"],
  confidence: 0.88,
  communication_primacy: 0.92,
  medium: ["written", "oral"],
  purpose: ["legitimation", "propaganda"],
  audience: ["Senate", "popular assembly"],
  strategy: ["exemplarity", "invective"]
})

// Count claims by facet (define sub-agent workload)
MATCH (subj:SubjectConcept)-[:HAS_FACET_CLAIM]->(claim:Claim)
RETURN claim.primary_facet, count(*) AS claim_count
// Expected: Military: 8, Political: 6, Social: 3, ..., Artistic: 0
```

---

## 2. Agent-Created SubjectConcepts & Registry

### **Problem**: How do agents create new SubjectConcepts?

**Phase 2A+2B will discover:**
- Direct Historical: ~1,847 entities (all can become SubjectConcepts later)
- Temporal Bridges: ~251 entities (modern validation entities)

**Agent should be able to claim:**
```
"I discovered a new, more granular subject: 'Caesar's Gaul Campaigns (58-50 BC)'"

Steps:
1. Check SubjectConceptRegistry: Does "Caesar's Gaul Campaigns" already exist?
2. If NO: Create new SubjectConcept with parent_concept_id = "Caesar's Military Career"
3. Register in SubjectConceptRegistry with:
   - label, wikidata_qid (if found), confidence (0.75+)
   - created_by_agent: agent_name, timestamp
   - validation_status: "pending_review" or "auto_approved" (if confidence >= 0.90)
4. Link to authorities: Search LCC/LCSH/FAST for matching concepts
```

### **SubjectConceptRegistry Node**

```cypher
(:SubjectConceptRegistry {
  registry_id: "registry_roman_republic_001",
  parent_concept_id: "subj_roman_republic_q17167",
  
  // Registry Metadata
  total_concepts: 45,
  concepts_by_source: {
    wikidata: 32,
    agent_created: 8,
    lcsh: 5
  },
  
  // Governance
  validation_threshold_confidence: 0.75,        // Agents CAN create if >= 0.75
  auto_approval_confidence: 0.90,               // Auto-approved if >= 0.90
  last_updated: datetime("2026-02-15"),
  curator: "human_expert_001",
  
  // LinkedList of concepts (ordered)
  concept_ids_ordered: [
    "subj_punic_wars_q3105",
    "subj_caesars_gaul_campaigns_local_1",
    "subj_hannibal_qid_1",
    ...
  ]
})

// Each SubjectConcept is registered
(registry:SubjectConceptRegistry)-[:CONTAINS]->(subj:SubjectConcept {
  label: "Caesar's Gaul Campaigns (58-50 BC)",
  parent_concept_id: "subj_caesars_military_career_q...",
  wikidata_qid: "Q181098",
  confidence: 0.92,
  created_by_agent: "GPT_PHASE_2_DISCOVERY_MAP",
  validation_status: "auto_approved",
  creation_timestamp: datetime("2026-02-15")
})
```

### **Agent Creation Workflow**

```python
class AgentSubjectConceptCreator:
    """Allows agents to claim new SubjectConcepts"""
    
    def claim_new_concept(self, 
                         label: str, 
                         parent_id: str = None,
                         wikidata_qid: str = None,
                         confidence: float = None,
                         evidence: str = None) -> Concept:
        """
        Agent claims a new, more granular concept
        
        Example:
          agent.claim_new_concept(
            label="Caesar's Gaul Campaigns (58-50 BC)",
            parent_id="subj_caesars_military_career",
            wikidata_qid="Q181098",
            confidence=0.92,
            evidence="Caesar's Commentarii de Bello Gallico"
          )
        """
        
        # Step 1: Check registry
        registry = self.get_registry(parent_id)
        if self.concept_exists(label, registry):
            return existing_concept  # Don't duplicate
        
        # Step 2: Validate confidence threshold
        if confidence < 0.75:
            raise ValidationError(f"Confidence {confidence} below 0.75 minimum")
        
        # Step 3: Create SubjectConcept node
        concept = SubjectConcept(
            concept_id=self.generate_id(),
            label=label,
            parent_concept_id=parent_id,
            wikidata_qid=wikidata_qid,
            source_agent=self.agent_name,
            confidence=confidence,
            validation_status="auto_approved" if confidence >= 0.90 else "pending_review",
            creation_timestamp=datetime.now()
        )
        
        # Step 4: Search authority databases
        concept.lcc_codes = self.search_lcc(label, wikidata_qid)
        concept.lcsh_ids = self.search_lcsh(label)
        concept.fast_ids = self.search_fast(label)
        
        # Step 5: Register
        registry.add_concept(concept)
        
        # Step 6: Return (ready for claims)
        return concept
```

### **Validation Status Workflow**

```
Agent Creates Concept (confidence: 0.87)
    ↓
Status: "pending_review" (0.75 ≤ confidence < 0.90)
    ↓
Human Reviewer: Approves/Rejects (within 24 hours)
    ↓
Status: "approved" OR "rejected"

---

Agent Creates Concept (confidence: 0.93)
    ↓
Status: "auto_approved" (confidence ≥ 0.90)
    ↓
Can be used immediately for claims
    ↓
Spot-check by human reviewer (weekly summary)
```

---

## 3. Facet Assignment Mechanism

### **How Facets Get Assigned to SubjectConcepts**

**Three channels:**

#### **Channel A: Phase 2A+2B GPT Claims**
```
GPT discovers: "Roman Republic had military tactics"
  ↓
Creates Claim:
  - text: "The Roman Republic's legionary formation provided tactical superiority"
  - primary_facet: "Military"
  - related_facets: ["Political", "Technological"]
  - confidence: 0.95
  - evidence: "Caesar's Commentarii"
  ↓
SubjectConcept("Roman Republic") gets facet claim
  ↓
Neo4j Query: Which facets does Roman Republic have?
  MATCH (subj:SubjectConcept)-[:HAS_FACET_CLAIM]->(claim:Claim)
  WHERE subj.label = "Roman Republic"
  RETURN claim.primary_facet, avg(claim.confidence) AS avg_confidence
  
  Result:
    Military: 0.93 (8 claims)
    Political: 0.91 (6 claims)
    Diplomatic: 0.89 (4 claims)
    Social: 0.87 (3 claims)
    Communication: 0.88 (2 claims)
```

#### **Channel B: Automated Authority Classification**
```
LCC classification: DG232-DG248 (Republic 510-27 BC)
  ↓
LCC→Facets mapping says: Political, Military, Diplomatic
  ↓
Assign facets to SubjectConcept via authority link:
MATCH (subj:SubjectConcept)-[:ALIGNED_WITH_LCC]->(lcc:LCC_Class)
WITH subj, lcc.facets AS facets
SET subj.authority_facets = facets
  ↓
Result: SubjectConcept gets facets from authority classification
```

#### **Channel C: Human Curation (UI/Spreadsheet)**
```
Curator opens UI: "Classify 'Roman Republic' by facet"
  ↓
Selects: Military (0.95), Political (0.98), Diplomatic (0.90)
  ↓
Creates manual Claim nodes:
  {primary_facet: "Military", confidence: 0.95, 
   source: "human_curator", validation_status: "approved"}
  ↓
All three channels contribute to SubjectConcept's facet profile
```

### **Facet Scores & Sub-Agent Definition**

```cypher
// After Phase 2A+2B, query shows sub-agent needs:
MATCH (subj:SubjectConcept {label: "Roman Republic"})-[:HAS_FACET_CLAIM]->(claim:Claim)
WITH claim.primary_facet AS facet, 
     avg(claim.confidence) AS confidence,
     count(*) AS claim_count
RETURN facet, confidence, claim_count, 
       CASE 
         WHEN claim_count >= 5 THEN "SUBAGENT_REQUIRED"
         WHEN claim_count >= 2 THEN "ANALYSIS_PENDING"
         ELSE "NOT_NEEDED"
       END AS recommendation
ORDER BY claim_count DESC

Result:
Military       | 0.93 | 8 claims  | SUBAGENT_REQUIRED
Political      | 0.91 | 6 claims  | SUBAGENT_REQUIRED
Diplomatic     | 0.89 | 4 claims  | ANALYSIS_PENDING
Social         | 0.87 | 3 claims  | ANALYSIS_PENDING
Communication  | 0.88 | 2 claims  | ANALYSIS_PENDING
Religious      | 0.82 | 1 claim   | NOT_NEEDED
Economic       | NULL | 0 claims  | NOT_NEEDED
Artistic       | NULL | 0 claims  | NOT_NEEDED
```

**Interpretation:**
- **Military SubAgent**: 8 high-confidence claims → specialize
- **Political SubAgent**: 6 high-confidence claims → specialize
- **Diplomatic SubAgent**: 4 medium-confidence claims → could specialize or defer
- **Communication SubAgent**: 2 claims, but primacy 0.88 → flag for focus
- **Religious Agent**: 1 claim → insufficient data
- **Economic/Artistic Agents**: No claims → don't instantiate

---

## 4. Multi-Authority Federation

### **The Challenge**
- LCSH has "Rome--History--Republic, 510-30 B.C." (sh85114436)
- FAST has "Rome--History--Republic" (1352255)
- LCC has "DG232-248" (Republic)
- Wikidata has "Q17167" (Roman Republic)
- **Are they the same thing?** Mostly yes, but with subtle boundaries.

### **Solution: Authority Alignment Confidence**

```cypher
// Many-to-One or One-to-Many mappings
(subj:SubjectConcept {label: "Roman Republic"})-[:ALIGNED_WITH_LCSH {
  alignment_type: "exact",
  confidence: 0.98,
  reasoning: "LCSH heading exactly matches temporal bounds (-509 to -27)"
}]->(lcsh:LCSH_Subject {lcsh_id: "sh85114436"})

(subj)-[:ALIGNED_WITH_LCSH {
  alignment_type: "partial",
  coverage: "includes",
  confidence: 0.85,
  reasoning: "LCSH allows geographic subdivisions (--Italy, --Provinces) as sub-concepts"
}]->(lcsh2:LCSH_Subject {lcsh_id: "sh85114437"})  // Rome--History--Republic--Sources

(subj)-[:ALIGNED_WITH_FAST {
  alignment_type: "approximate",
  coverage: "overlaps",
  confidence: 0.88,
  reasoning: "FAST is less granular on dates (doesn't distinguish 510 vs 27 BC boundary)"
}]->(fast:FAST_Subject {fast_id: 1352255})

(subj)-[:ALIGNED_WITH_LCC {
  alignment_type: "exact",
  coverage: "exact",
  confidence: 0.99,
  reasoning: "DG232-248 defined specifically for Republic period"
}]->(lcc:LCC_Class {code: "DG232-248"})
```

### **Query: What are the authorities saying about "Roman Republic"?**

```cypher
MATCH (subj:SubjectConcept {label: "Roman Republic"})-[r]->(auth)
WHERE type(r) STARTS WITH "ALIGNED_WITH"
RETURN 
  type(r) AS authority_type,
  auth.label AS authority_label,
  r.alignment_type,
  r.confidence,
  r.reasoning
ORDER BY r.confidence DESC

Result:
ALIGNED_WITH_LCC       | DG232-248        | exact      | 0.99 | DG232-248 defined...
ALIGNED_WITH_LCSH      | Rome--History... | exact      | 0.98 | LCSH heading exactly...
ALIGNED_WITH_FAST      | Rome--History... | approximate| 0.88 | FAST is less granular...
```

### **Authority Conflict Resolution**

```
Scenario: LCSH says "Rome--History--Republic, 510-30 B.C."
         But LCC says "DG232-248 (Republic 510-27 BC)"
         Dates differ: 30 vs 27 BC

Solution in Chrystallum:
  - SubjectConcept uses most authoritative source (LCC: 27 BC)
  - Record both authority dates:
    lcc_period_end: -27,
    lcsh_period_end: -30,
    authoritative_date: -27,
    authoritative_source: "LCC DG232-248"
  - Flag discrepancy for human review:
    authority_conflict: "Date boundary: LCC -27 vs LCSH -30",
    confidence_penalty: -0.05
```

---

## 5. FAST Parsing Strategy

### **Goal**: Extract FAST subjects into distinct concepts with metadata

### **FAST Data Source**
- File: `FAST/FASTTopical.marcxml`
- Format: MARC XML (Authority records)
- Estimated: 100K+ subject records
- Contains: ID, preferred label, variant forms, relationships

### **Parsing Pipeline**

```python
# Phase 1: Extract distinct FAST subjects from MARCXML
class FASTParser:
    def parse_marcxml_to_csv(self, marcxml_path):
        """
        Input: FASTTopical.marcxml
        Output: fast_subjects_extracted.csv with columns:
          - fast_id (e.g., 1352255)
          - preferred_label (e.g., "Rome--History--Republic")
          - variant_labels (e.g., ["Rome--Republic", "Roman Republic"])
          - record_type (e.g., "Topical", "Chronological", "Geographic")
          - scope_note (e.g., "Used for general discussions of...")
          - broader_terms (e.g., [1352250, 1352260])  # FAST IDs
          - narrower_terms (e.g., [1352300, 1352301])
          - related_terms (e.g., [1352256])
          - wikidata_link (if extractable)
          - source_updated (date from MARC record)
        """
        
        fast_subjects = []
        tree = ET.parse(marcxml_path)
        root = tree.getroot()
        
        for record in root.findall("record"):
            # Extract FAST ID from field 001
            fast_id = self._extract_field(record, "001")
            
            # Extract preferred label from field 150/450 (depends on record type)
            preferred_label = self._extract_field(record, "150")
            
            # Extract variant labels
            variants = self._extract_fields(record, "450")  # See also
            
            # Extract scope note
            scope_note = self._extract_field(record, "680")
            
            # Extract BT/NT/RT relationships
            bt = self._extract_fields(record, "550", "a=$w bt")  # Broader terms
            nt = self._extract_fields(record, "550", "a=$w nt")  # Narrower terms
            rt = self._extract_fields(record, "550", "a=$w rt")  # Related terms
            
            fast_subjects.append({
                "fast_id": fast_id,
                "preferred_label": preferred_label,
                "variant_labels": variants,
                "record_type": "Topical",  # or Chronological, Geographic
                "scope_note": scope_note,
                "broader_terms": bt,
                "narrower_terms": nt,
                "related_terms": rt,
                "wikidata_link": None  # Try to infer from label
            })
        
        return fast_subjects

# Phase 2: Load into Neo4j
def load_fast_to_neo4j(fast_subjects_csv):
    """
    Create FAST_Subject nodes in Neo4j
    """
    
    cypher = """
    UNWIND $subjects AS subj
    MERGE (fast:FAST_Subject {fast_id: subj.fast_id})
    SET fast.preferred_label = subj.preferred_label,
        fast.variant_labels = subj.variant_labels,
        fast.record_type = subj.record_type,
        fast.scope_note = subj.scope_note,
        fast.authority_tier = "TIER_2",  # FAST is tier 2
        fast.created_date = datetime()
    
    WITH fast, subj
    // Optional: Link to SubjectConcepts if matched
    OPTIONAL MATCH (subj_concept:SubjectConcept)
    WHERE subj_concept.label CONTAINS subj.preferred_label
    CREATE (subj_concept)-[:ALIGNED_WITH_FAST {
      fast_id: subj.fast_id,
      confidence: 0.85,
      alignment_type: "inferred_from_label"
    }]->(fast)
    """
    
    # Execute in batches
    for batch in chunked(fast_subjects, 500):
        session.run(cypher, subjects=batch)
```

### **Expected Output**

```csv
fast_id,preferred_label,variant_labels,record_type,scope_note,broader_terms,narrower_terms,related_terms
1352255,"Rome--History--Republic","['Rome--Republic','Roman Republic']","Topical","Used for works discussing the political...","[1352250]","[1352256,1352257]","[1352260]"
1352256,"Rome--History--Republic--Military","['Rome--Military','Roman Legions']","Topical","Military aspects of Republican Rome","[1352255]","[1352301,1352302]","[1352401]"
...
```

### **Registry Integration**
```cypher
// After FAST parsing, check alignment with SubjectConcepts
MATCH (fast:FAST_Subject {preferred_label: "Rome--History--Republic"})
OPTIONAL MATCH (subj:SubjectConcept {label: "Roman Republic"})
OPTIONAL MATCH (registry:SubjectConceptRegistry {parent_concept_id: subj.concept_id})

RETURN fast.fast_id, subj.concept_id, registry.registry_id
// Creates alignment opportunities
```

---

## 6. Complete Ontology Design Summary

### **Node Types**
```
SubjectConcept (hub, represents a scholarly topic)
  ├── LCC_Class (Library of Congress Classification codes)
  ├── LCSH_Subject (Library of Congress Subject Headings)
  ├── FAST_Subject (Faceted Application of Subject Terminology)
  ├── Claim (facet-based knowledge statements)
  ├── SubjectConceptRegistry (governance for concept creation)
  └── SubjectConcept (child concepts for hierarchy)
```

### **Relationship Types**
```
SubjectConcept -[:ALIGNED_WITH_LCC]-> LCC_Class
SubjectConcept -[:ALIGNED_WITH_LCSH]-> LCSH_Subject
SubjectConcept -[:ALIGNED_WITH_FAST]-> FAST_Subject
SubjectConcept -[:HAS_FACET_CLAIM]-> Claim
SubjectConcept -[:HAS_CHILD_CONCEPT]-> SubjectConcept
SubjectConcept -[:REGISTERED_IN]-> SubjectConceptRegistry
SubjectConceptRegistry -[:CONTAINS]-> SubjectConcept
```

### **Data Flow for Phase 2A+2B**

```
GPT Discovers Entity: "Roman Republic"
  ↓
Queries SubjectConceptRegistry: Does "Roman Republic" exist?
  ↓
IF YES: Get existing SubjectConcept node ID
  ↓
Generate Facet Claims:
  - Claim 1: "Military tactics..." (Military facet, 0.95 confidence)
  - Claim 2: "Political institutions..." (Political facet, 0.91 confidence)
  - Claim 3: "Caesar's propaganda..." (Communication facet, 0.88 confidence)
  ↓
Create Claim nodes, link to SubjectConcept
  ↓
IF NO: Agent can create new SubjectConcept (via claim_new_concept API)
  ↓
Register in SubjectConceptRegistry (if confidence >= 0.75)
  ↓
Search LCC/LCSH/FAST for alignments (async, can be deferred)
  ↓
Create alignment relationships with confidence scores
```

### **Implementation Roadmap**

| Phase | Component | Timeline | Blocking |
|-------|-----------|----------|----------|
| **Now** | SubjectConcept schema + registry | Done | No |
| **Phase 2A+2B** | GPT creates SubjectConcept nodes + Claim nodes | ~30 min | No |
| **Week 1-2** | FAST parser + load FAST_Subject nodes | ~2-3 hours | No |
| **Week 2** | LCSH loader + LCSH_Subject nodes | ~3-4 hours | Extends to... |
| **Week 2-3** | Authority alignment queries + confidence scoring | ~2 hours | No |
| **Phase 3** | Multi-authority federation queries + RDF export | ~4-5 hours | No |

---

## Next Steps

1. **Approve Ontology Design** (this document)
2. **Create SubjectConcept/Registry schema in Neo4j** (Week 1)
3. **Update Phase 2A+2B GPT prompt** to reference SubjectConceptRegistry
4. **Parse FAST MARCXML** to extract subject list (Week 1-2)
5. **Implement authority alignment queries** (Week 2-3)
6. **Build multi-authority federation dashboard** (Phase 3)

