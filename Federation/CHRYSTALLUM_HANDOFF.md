# Chrystallum Knowledge Graph — Agent Handoff Document
**Date:** 2026-02-23 (legacy)  
**Graph:** Neo4j Aura  
**Subject domain (current):** Roman Republic  
**Status:** Legacy — ITGAR/governance spec; not built

> **New advisors:** Use `docs/ADVISOR_HANDOFF_2026-02-25.md` for current ramp-up. This document retains ITGAR, Fischer check, and governance design for future reference.

---

## What This System Is

Chrystallum is a **self-describing, self-aware knowledge graph** for historical
research built on Neo4j Aura. The defining property: the graph holds a model of
itself as a first-class node (`(:SystemDescription)`), generated from its own
structure, stored back in the graph, readable by its own query interface.

Any agent connecting to Chrystallum should read the self-description node first.
It provides live orientation to the graph's state without hardcoded context.

```cypher
MATCH (c:Chrystallum)-[:HAS_SELF_DESCRIPTION]->(sd:SystemDescription)
RETURN sd.narrative, sd.federation_summary, sd.subject_summary,
       sd.federation_count, sd.subject_concept_count, sd.anchor_coverage_pct
```

---

## Graph Architecture

### Root structure

```
(:Chrystallum {name, version, created})
  -[:HAS_FEDERATION_ROOT]->(:FederationRoot)
    -[:HAS_FEDERATION]->(:Federation) × 13
  -[:HAS_SUBJECT_CONCEPT_ROOT]->(:SubjectConceptRoot)
    -[:HAS_SUBJECT_REGISTRY]->(:SubjectConceptRegistry)
      -[:CONTAINS]->(:SubjectConcept) (hierarchical, PART_OF chains)
  -[:HAS_SELF_DESCRIPTION]->(:SystemDescription)
  -[:HAS_VOCABULARY_ROOT]->(:VocabularyRoot)   ← NEW this session
    -[:HAS_CATEGORY]->(:VocabCategory) × 4
      -[:HAS_TERM]->(:VocabTerm) × 54
```

### Federation layer (13 total)

| Name | Type | Mode | Coverage |
|------|------|------|----------|
| Pleiades | geographic | local | 41,993 places |
| PeriodO | temporal | local | 8,959 periods |
| Wikidata | universal | hub_api | — |
| GeoNames | geographic | hybrid | — |
| BabelNet | linguistic | api | — |
| WorldCat | bibliographic | api | — |
| LCSH | conceptual | local | — |
| FAST | topical | local | — |
| LCC | classification | local | — |
| MARC | bibliographic | local | — |
| **Trismegistos** | prosopographic | api | 575,000 persons |
| **LGPN** | prosopographic | api | 400,000 persons |
| **SNAP:DRGN** | prosopographic | standard | 0 (standard only, triplestore defunct) |

SNAP:DRGN is an interchange standard, not a queryable endpoint. It lives in the
graph to explain why Trismegistos and LGPN crosswalk correctly with each other.
`crosswalk_standard: "SNAP:DRGN"` is set as a property on both federation nodes.

### Authority Federation States (epistemic scoring)

```
FS4_VERIFIED   — entity anchored to multiple federations with high confidence
FS3_FEDERATED  — anchored to at least one federation
FS2_CANDIDATE  — possible federation match, not confirmed
FS1_REGISTERED — federation node exists, no match yet
FS0_SYNTHETIC  — generated by pipeline, not authority-confirmed
```

### SubjectConcept hierarchy (Roman Republic domain)

```
Level 0 — root anchor (e.g. Roman Republic Q17167, LCSH/FAST/LCC anchored)
Level 1 — domain clusters (POLITICAL, MILITARY, ECONOMIC, CULTURAL, etc.)
Level 2 — sub-topics within clusters
Level 3 — leaf concepts (specific subjects, methods, source types)
```

Level 0 nodes carry: `qid`, `lcsh_id`, `fast_id`, `lcc_class`, `lcc_subclass`,
`authority_federation_score` (0–100), `authority_federation_cipher`.

---

## Data Pipeline (existing, complete)

Scripts live in the repo. Run in order:

```
1. find_anchors.py              — Wikidata SPARQL → candidate entities
2. validate_anchors.py          — multi-source validation, FS scoring
3. harvest_all_anchors.py       — property harvesting from federations
4. facet_classifier.py          — assigns primary_facet from 18-facet vocabulary
5. cluster_assignment.py        — MEMBER_OF edges to SubjectConcept hierarchy
6. prosopographic_crosswalk.py  — BIOGRAPHICAL entities → TM/LGPN enrichment
7. generate_system_description.py — introspect graph, generate SystemDescription node
```

All scripts output Cypher files for inspection (`--cypher`) or write
directly to Aura (`--write --neo4j-uri ... --neo4j-password ...`).

---

## ITGAR Architecture (specified this session, not yet built)

ITGAR = Input → Trigger → Goal → Action → Result

The historian agent's unit of analysis is a **person participating in an event**.
For each participant, one ITGAR claim is built.

**Critical distinction:** Input is structural condition (persisted). Trigger is
activating event (why act *now*). Caesar faced senatorial opposition for months
(Input). Senate deadline ultimatum January 7, 49 BCE (Trigger).

### New node types to build

```
(:Event)       — first-class, distinct from SubjectConcept
(:Claim)       — ITGAR record + full debate lifecycle
(:Controversy) — records known disputed points between near-equal competing claims
```

### Claim lifecycle

```
pending → in_debate → approved | approved_with_dissent | held | rejected
```

### Vocabulary federation (BUILT this session, load with load_itgar_vocabulary.py)

```
(:VocabularyRoot {name: "ITGAR Vocabulary", version: "1.0"})
  10 Goal types: POL, PERS, MIL, ECON, CONST, MORAL, CULT, RELIG, DIPL, SURV
  10 Trigger types: CIRCUM, MORAL_TRIGGER, EMOT, POL_TRIGGER, PERS_TRIGGER,
                    EXT_THREAT, INT_PRESS, LEGAL, AMB, OPPORT
  15 Action types: REVOL, MIL_ACT, CRIME, DIPL_ACT, CONST_INNOV, ECON_ACT,
                   LEGAL_ACT, SOC_ACT, RELIG_ACT, PERS_ACT, ADMIN, CAUSAL,
                   TYRANNY, DEFENSIVE, OFFENSIVE
  19 Result types: POL_TRANS, INST_CREATE, CONQUEST, DEFEAT, ALLIANCE, TRAGIC,
                   SUCCESS, FAILURE, STABILITY, INSTABILITY, LEGAL_OUTCOME,
                   CULT_CHANGE, PERS_OUTCOME, ECON_OUTCOME, SOC_CHANGE,
                   RELIG_OUTCOME, MORAL_VICT, MORAL_FAIL, NEUTRAL
```

All types have Wikidata QID anchors. Provenance: derived from 18-facet vocabulary,
validated by convergence with LCSH, APh, IB/AP frameworks, CIDOC-CRM E7 (partial).

---

## Fischer Fallacy Check (BUILT — fischer_check.py)

Five-check validator for ITGAR claims. Run before governance submission.

| Check | Severity | Trigger condition |
|-------|----------|-------------------|
| Goal-Action Warrant | HIGH | `goal.inferred=true AND goal.sources=[]` |
| Teleological Projection | MEDIUM | `result.intended=false AND text_overlap(goal,result)>0.6` |
| Single Cause Fallacy | LOW | One input for REVOL/MIL_ACT/POL action |
| Agency Overclaim | MEDIUM | Structural input + high-confidence personal goal |
| Trigger-Goal Disconnect | MEDIUM | Incompatible semantic domains, no bridging source |

HIGH severity = claim BLOCKED. MEDIUM/LOW = enters debate with flags.

---

## Governance Rules (BUILT — governance.py)

Adjudicated by SubjectConceptAgent after debate.

Approvability conditions (ALL must hold):
```
bayesian_confidence >= 0.75
AND fischer_severity IN ["none", "low", "medium"]
AND action.sources not empty
AND no contradiction with existing APPROVED claim at confidence >= 0.90
```

Tiered approval:
```
>= 0.85              → APPROVED (primary claim)
0.60 – 0.84          → APPROVED_WITH_DISSENT
< 0.60               → HELD
```

Contradictory claims within 0.10 confidence of each other: both held with
`(:Controversy)` node. Epistemically honest — the graph preserves both views.

---

## Agent Architecture (SPECIFIED — not yet implemented)

```
SubjectConceptAgent (parent, moderator, LangGraph supervisor)
  ↓ fan-out to 18 Subject Facet Agents (SFAs) — one per facet
Each SFA:
  1. Reads (:SystemDescription) → orientation
  2. Reads (:VocabularyRoot) → type system
  3. Identifies Events in its facet domain
  4. Builds ITGAR claims per participant per event
  5. Runs Fischer check locally
  6. Submits claims to SubjectConceptAgent
  ↓ LangGraph fan-in: all claims visible to all SFAs
  ↓ Debate round: SFAs challenge/support/abstain
  ↓ SubjectConceptAgent adjudicates
  ↓ Graph update: Event + Claim + Controversy nodes → Aura
  ↓ SystemDescription regenerated
```

**Recommended stack:** LangGraph for parallel debate orchestration + Neo4j
Claim nodes for state persistence. Not redundant — complementary layers.

---

## Files in Repository

### Data pipeline (existing)
- `find_anchors.py`
- `validate_anchors.py`
- `harvest_all_anchors.py`
- `facet_classifier.py`
- `cluster_assignment.py`
- `prosopographic_crosswalk.py`
- `generate_system_description.py`

### Cypher
- `add_prosopographic_federations.cypher` — adds Trismegistos, LGPN, SNAP nodes
- `system_description_read_queries.cypher` — 7 read queries for MCP agents

### ITGAR layer (new this session)
- `itgar_spec.md` — full design spec, node schemas, governance rules, agent hierarchy
- `fischer_check.py` — executable Fischer fallacy validator
- `governance.py` — SubjectConceptAgent adjudication logic
- `load_itgar_vocabulary.py` — loads vocabulary CSVs into graph as VocabularyRoot
- `itgar_vocabulary_load.cypher` — generated Cypher (59 statements, run in Aura)

### Design records
- `prosopographic_federation_design.md`

### Source CSVs
- `action_structure_vocabularies.csv` — Category, Type, Code, Description, Examples
- `action_structure_wikidata_mapping.csv` — Category, Our_Code, Our_Type, Wikidata_QID, Wikidata_Label

---

## Known Design Debt — subject_id Architecture (IMPORTANT)

This is an open refactor decision the next agent should understand before touching
any SubjectConcept-related code.

### Current state (fragile)

`subject_id` values like `subj_rr_soc_family_gentes` and `subj_rr_family_gentes` are
**hand-authored keys** in `load_roman_republic_ontology.py`. The `rr` segment is a
magic string encoding "Roman Republic" — it is not derived from any QID.

The problem exposed by this specific example: both `subj_rr_soc_family_gentes` (Level 2,
society → family) and `subj_rr_family_gentes` (Level 3, family → gentes) both resolve
to the same Wikidata anchor `Q899409` ("gens"). So:

- Two distinct SubjectConcepts share one Wikidata QID
- The `subject_id` encodes a path through a hand-authored hierarchy
- The LLM plays no role in concept identity — it only fills in anchors after the fact
- `harvest_all_anchors.py → deduplicate_by_qid()` groups them, but the semantic
  overlap is a sign that the concept hierarchy itself is over-specified relative
  to available Wikidata anchors

### How subject_id is currently generated

```
Step 1: load_roman_republic_ontology.py  — hand-authored ONTOLOGY dict keys
Step 2: find_subject_concept_anchors.py  — reads those keys via AST, assigns QIDs
Step 3: subject_concept_wikidata_anchors.json — stores subject_id + anchor_qid
Step 4: harvest_all_anchors.py           — groups by QID, builds qid_to_subject_ids
Step 5: cluster_assignment.py            — MEMBER_OF edges use subject_id
```

### The proposed architecture (not yet implemented)

Invert the flow. LLM reasons first, QIDs drive identity:

```
Domain root QID (e.g. Q17167 = Roman Republic)
  ↓
LLM: "What scholarly concepts exist under this domain?"
  → Returns: [{ label: "Families and gentes", best_qid: "Q899409" }, ...]
  ↓
subject_id = f"subj_{root_qid}_{anchor_qid}"  // e.g. subj_Q17167_Q899409
  OR
subject_id = f"subj_{anchor_qid}"              // e.g. subj_Q899409
```

Under this scheme:
- `rr` disappears — only QIDs
- Two SubjectConcepts that resolve to the same QID are the same concept (not two
  hierarchical entries with different slugs)
- Concept identity is grounded in Wikidata, not in a hand-authored string
- The domain root QID in the ID (e.g. `subj_Q17167_Q899409`) makes the scoping
  explicit and machine-readable

**`make_subject_id()` in `subject_domain_config.py` already generates canonical
`subj_q17167_*` IDs** — the Roman Republic ontology just predates that convention.
The refactor is replacing the legacy `subj_rr_*` keys with QID-derived ones.

### What this means for ITGAR

The `Claim` node references `event_id` and `subject_qid`. If SubjectConcepts shift
to QID-derived IDs, the Claim model is actually cleaner — `subject_qid` *is* the
SubjectConcept identity, no slug translation needed.

**Recommendation:** Do the subject_id refactor before building SFAs, or the SFAs
will embed the legacy slug pattern and the debt compounds.

---

## Pending Work (next agent)

In priority order:

**0. Refactor subject_id to QID-derived scheme**
Replace `subj_rr_*` legacy keys in `load_roman_republic_ontology.py` with
`subj_Q17167_{anchor_qid}` pattern. Update `find_subject_concept_anchors.py`,
`cluster_assignment.py`, and any other script that reads or writes `subject_id`.
Do this before building SFAs — the SFAs will use SubjectConcept identifiers
and the legacy slugs will pollute the agent layer.

**1. Load vocabulary into graph**
Run `itgar_vocabulary_load.cypher` in Aura browser, or:
```bash
python load_itgar_vocabulary.py --uri "neo4j+s://..." --user neo4j --password "..."
```

**2. Build Event + Claim node writers**
Implement write logic to materialize Event and Claim nodes from ITGAR payloads.
Governance patches are already generated by `governance.py` as Cypher strings —
need a writer that applies them to Aura.

**3. SFA implementation**
Start with SFA_POLITICAL and SFA_MILITARY as the two most developed domains.
Each SFA needs: SystemDescription reader, VocabularyRoot reader, Event identifier,
ITGAR builder, Fischer check caller, claim submitter.

**4. LangGraph orchestrator**
Fan-out → SFAs → fan-in → debate → SubjectConceptAgent → graph write.
The governance.py adjudication logic is the SubjectConceptAgent's core.

**5. Controversy surfacing**
Update `generate_system_description.py` to include controversy count and examples
in the SystemDescription narrative. The graph should describe its own disputes.

**6. Additional online authorities (candidates)**
These were identified as valuable additions not yet added:
- **UNESCO Thesaurus** — SKOS-native, live SPARQL endpoint, economics/social science/culture
- **APh (L'Année Philologique)** — de facto subject classification ancient historians use;
  not machine-readable but importable as local CSV federation
- **Getty AAT** — military/art/material culture hierarchy; complements LCSH
- **TGM (Thesaurus for Graphic Materials)** — LoC, LCSH-adjacent, strong military coverage
- **ATLA Religion Database** — ancient religion better than LCSH
- **JEL (Journal of Economic Literature)** — economics taxonomy, academic metadata standard
- **VIAF** — virtual international authority file for persons (crosswalk already in
  prosopographic_crosswalk.py via Wikidata P1605)

---

## Key Architectural Decisions (do not reverse without good reason)

**Self-description in graph, not docs.** Single `(:SystemDescription)` node,
regenerated when version changes or >24h stale. No manually maintained docs.

**Tiered claim approval, not single winner.** Multiple claims about the same
person-event coexist at confidence tiers. The minority view matters historically.

**Fischer check as pre-submission gate, not post-hoc review.** HIGH severity
blocks submission. Medium/low flags enter the debate record. This forces SFAs
to provide evidence before making goal attributions.

**SNAP:DRGN as standard, not federation.** The triplestore is defunct. SNAP's
value is as an interchange standard. Record it that way; don't try to query it.

**Lens is runtime, not schema.** Events can be queried as subject_concept,
temporal period, or event depending on the agent's task. Don't bake lens
selection into the schema.

**SO relationships deferred.** Two-hop traversal via shared SubjectConcept
already encodes subject-object relationships. Materialize explicit RELATED_TO
edges only when typed predicates (causal direction, temporal ordering) are needed.

---

## How to Bootstrap a New Agent Session

1. Query the self-description node (see Cypher above)
2. Read this handoff document
3. Check `itgar_spec.md` for the full ITGAR/governance spec
4. Check `prosopographic_federation_design.md` for the federation rationale
5. The vocabulary is in the graph under `(:VocabularyRoot {name: "ITGAR Vocabulary"})`
   — query it to verify before building SFAs

---

## Claude Code Note

Claude Code (the product relevant for future development) is a terminal-based
agentic coding tool. Install it locally with your Claude subscription and run
`claude` in your project directory. It reads your codebase, edits files, runs
commands, and integrates with your terminal tools. Relevant for this project:
- CLAUDE.md in the repo root can document conventions Claude Code should follow
- It supports MCP servers — the Chrystallum MCP tools could be wired in
- It can run the pipeline scripts and debug errors autonomously
- LangGraph orchestration code is a good fit for Claude Code's multi-file edit capabilities

The chat interface (where these sessions happened) is better for architecture
and specification work. Claude Code is better for implementation sprints once
the design is clear.

---

## Authority Role Separation (important for agent design)

A key insight from earlier research: these authorities are NOT interchangeable.
Each has a distinct lane. Confusing them produces architectural drift.

| Authority | Lane | Used for |
|-----------|------|----------|
| Wikidata | Identity hub | Entity identity, crosswalk IDs, QID anchors |
| LCSH / FAST / LCC | Topical classification | Subject headings, library-grade aboutness |
| UNESCO Thesaurus | Domain concepts (education, social, economic, cultural) | SKOS-native SPARQL, multilingual labels, broader/narrower hierarchy |
| BabelNet | Multilingual normalization | Text → synset → candidate concept ID (ingestion time only, not stored as authority) |
| CIDOC-CRM / CRMinf | Event structure | Structural ontology: E7 Activity, E5 Event, E21 Person, justification nodes |
| Pleiades / GeoNames | Place identity | Geographic authority |
| PeriodO | Temporal identity | Period definitions with source citation |
| Trismegistos / LGPN | Person identity (ancient) | Prosopographic crosswalk for non-elite persons |

### The CRM question for Chrystallum

CIDOC-CRM is NOT currently in the federation layer. The relevant framing:

CRM gives you the **structure** of an event (type, participants, when, where,
justification). Subject authorities (UNESCO, LCSH, FAST) give you what the
event is **about**. BabelNet is used only during text → concept normalization,
not stored as a persistent authority node.

For Chrystallum's ITGAR model: the ITGAR payload (Input, Trigger, Goal, Action,
Result) does roughly what CRM E7 Activity does — but with historian-specific
structure (goal attribution, trigger distinction) that CRM doesn't model natively.
CRM's `CRMinf` inference layer (I2 Belief, I4 Proposition Set) is the closest
analog to Chrystallum's Claim + confidence + debate model.

**Decision pending:** whether to crosswalk ITGAR claims to CIDOC-CRM/CRMinf
identifiers for interoperability with the digital humanities ecosystem.
High scholarly value but not a blocker for the current build.

### Five concrete agent use cases (mapped to Chrystallum)

**1. Subject tagging at ingestion** — Agent reads a source, proposes topics,
uses BabelNet to normalize text phrases to synsets → candidate Wikidata/LCSH/UNESCO
concepts → attaches SKOS concepts to source node. CIDOC-CRM not involved (no event
being modelled yet, only aboutness). Maps to: future source ingestion pipeline.

**2. Historical event modelling with topical facets** — Structural agent creates
the event node with participants, place, timespan; Subject agent attaches SKOS
concepts for what the event is about. CRM gives structure; UNESCO/LCSH give
aboutness. Maps directly to: ITGAR Action node + VocabTerm type codes. The
VocabTerm Wikidata QID anchors are the bridge between ITGAR types and the
broader SKOS concept space.

**3. Multilingual query expansion** — BabelNet gets multilingual senses for a
query term; UNESCO Thesaurus returns broader/narrower in multiple languages;
query rewrites to concept URI filter rather than keyword. Relevant when the
graph is queried in languages other than English (Latin sources, modern
scholarship in French/German/Italian).

**4. Vocabulary crosswalk** — Alignment agent takes LCSH/FAST heading, uses
BabelNet/Wikidata to understand concept, searches UNESCO Thesaurus for match,
proposes `skos:exactMatch` or `skos:closeMatch`. Operational agents use
"SubjectConcept" as a single abstraction without caring which authority it
came from. This is exactly the VocabularyRoot federation pattern already in
the graph — the UNESCO federation would feed into the same node type.

**5. Concept-aware retrieval (Graph RAG)** — Retrieval agent walks the KG
using typed event edges (CRM-style structure) + SKOS concept constraints
(UNESCO/LCSH topical). Explanation agent shows: "This event matched because
it is typed as a military action (ITGAR type MIL_ACT, Wikidata Q178561) and
has subjects UNESCO:ArmedConflict + LCSH:Rome/History." This is the target
end-state for Chrystallum query agents once the Event + Claim layer is built.

---

## Property Allowlist Scope Contract

The harvester's property allowlist is intentionally narrow. This is a permanent
architectural decision, not a gap to be filled. The rationale:

| Layer | Role | Property scope |
|-------|------|----------------|
| **Harvester** | Entity discovery via backlinks (and later forward traversal) | Narrow — semantic entry points only |
| **Entity store** | Persist full claims for accepted entities | All properties, including P373, P910, P1422, etc. |
| **Edge building** | Create relationships between entities in the store | Full property set |
| **SFA** | Reasoning over the graph, finding non-obvious paths | Full graph |

The allowlist controls *which properties are used to discover candidate
entities*, not which properties are stored or reasoned over. Once an entity
is accepted into the store, its full Wikidata claim set is persisted —
including structural and administrative properties that would be noise as
discovery entry points.

This means a Roman senator and a mollusk can be connected via a shared Commons
category (P373) or Wikipedia template (P1422) without P373 ever appearing in
the harvester's allowlist. The senator gets discovered via P39 (office held),
the mollusk via P921 (main subject) or P138 (named after). Both land in the
entity store with full property sets. The edge-building layer creates the
P373 relationship between them. The SFA finds and reasons over the path
when needed.

**Decision rule for future allowlist changes:** Add a property to the
harvester allowlist only if it would discover entities that *no current
semantic property would find* — i.e., entities that are genuinely unreachable
via the existing set. If the entity would enter the store anyway and you
just want the edge, that is entity store and edge-building work, not harvester
work.

**Current known gap:** Dead anchors (zero backlinks) where the concept QID
is too abstract to attract backlinks but has rich forward neighbors (e.g.
Q2916317 military roles → Q1114493 Roman army). Fix is forward traversal,
not allowlist expansion. Revisit the allowlist only if post-SFA analysis
shows systematic entity class gaps that forward traversal does not close.

---

### UNESCO Thesaurus integration path

UNESCO is SKOS-native with a live SPARQL endpoint at
`https://vocabularies.unesco.org/browser/en/about`. Adding it as a federation
follows the same pattern as FAST/LCC (hub_api or local mode). The highest-value
mapping for Roman Republic domain is not UNESCO's core education coverage but:

- Economics facet: strong economic and trade concepts
- Social change / cultural facets: directly applicable
- International law / diplomacy facets: well-covered (treaties, alliances, DIPL type)
- Governance and institutions: useful for CONST, LEGAL action types

The `subj_Q17167_*` refactor (see Design Debt section) is a prerequisite.
UNESCO concepts would register as SubjectConcept anchors alongside Wikidata/LCSH,
and the legacy `subj_rr_*` slugs don't support that cleanly.
